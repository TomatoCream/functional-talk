#+REVEAL_ROOT: https://cdn.jsdelivr.net/npm/reveal.js
#+OPTIONS: toc:nil reveal_mathjax:t
#+REVEAL_THEME: night
#+TITLE: Functional Programming: Real World Performance, Nix and Warp Server
* Who am I? Introduction to myself
  - Follow me on github!
    [[https://github.com/TomatoCream]]
  - Linux user for 5 years now
    - Ubuntu
    - Proxmox
    - ArchLinux
    - Centos (server management)
** My interests
   - AI, ML
   - Functional programming and abstraction (what the hell is so good about this?)
** For whom is this talk for?
   - Linux users! Sorry windows users
     - But not really (departs away from a unix way of doing things)
   - Show you what functional programming can do?
     - purity?
     - referential transparency?
   - State management
   - DevOps
   - Images, Docker, VM, Clusters
   - I will give you a feel of ~Nix~ not the nitty gritty details
* The big problem
  - Has anyone ever used some sort of package management system?
** Some modern day package management systems
   | Package manager | Distributions  |
   |-----------------+----------------|
   | apt, apt-get    | Debian, Ubuntu |
   | rpm, yum        | Redhat, Centos |
   | pacman          | ArchLinux      |
   | brew            | MacOS          |
** What about sub ecosystems?
   | Package manager             | ???            |
   |-----------------------------+----------------|
   | pip, virtualenv, pipenv     | Python2,3(???) |
   | npm, yarn                   | Nodejs         |
   | cabal, stack, hackage       | Haskell :)     |
   | go?                         | go?            |
   | brew                        | MacOS          |
   | use-package, vim, fish, zsh | ...            |
** How to make a package manager?
   - What are the basic parts that we need?
** How to make a package manager?
   | build dependencies   | What do I need to build the program? |
   | runtime dependencies | What ~.so~ shared objects do I need? |
   | configurations       | What in ~/etc/...~ config files      |
   - essentially think of it as a graph, whenever we upgrade or install a package,
     we are mutating a node on this graph to point to something else.
** Problems with modern package management
   https://wiki.debian.org/DontBreakDebian#Don.27t_make_a_FrankenDebian
   [[file:./images/screenshot-01.png]]
** TODO Why imperative is bad? What is so imperative about installing packages?
   referential transparency
** Are you familiar with ~DEPENDENCY HELL~?
   - https://www.reddit.com/r/ProgrammerHumor/comments/75txp4/nodejs_dependency_hell_visualized_for_the_first/?utm_source=share&utm_medium=web2x
   - https://github.com/vector-im/riot-web/network/dependencies
** All types of "DEPENDENCY HELL"
   https://miro.medium.com/max/984/0*7ezJOtYUkI5zyqWU.png
   - { DLL, dependency, npm, cabal } hell, different names for the same demon
   - conflicting dependency
     - shared components like library links ~cuda.7.so~ vs ~cuda.6.so~
   - multiple version side by side and roll backs
   - possible solutions
     - set of stable packages like ~Debian~ or ~haskell stack snapshots~
** Not Atomic 01
   - kill upgrades half way
     - packages left in a semi updated state
     - sometimes need to manually remove lock files
   #+BEGIN_SRC sh
   COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF   NODE NAME
   dpkg    29329 root    3uW  REG    8,7        0 262367 /var/lib/dpkg/lock
   #+END_SRC
** Not Atomic 02
   - can be fixed but kinda troublesome.
   [[file:./images/screenshot-02.png]]
** Whats bad about imperative summary?
   - No referential transparency
     - cannot point to older versions of the same thing
   - Dependency hell
     - conflicting dependencies
   - Not atomic upgrades
     - unknown state if break half way
   These problems are really similar to the problems with imperative languages!
   like ~JAVA~ and people have already made solutions for them like how ~Haskell~
   does. We could learn a thing or two from them.
* What it should/could/would have been?
  - Imagine now that we implemented all the things of a functional programming
    language to create a functional package management system?
  - What can we do with this?
** GUIX vs Nix
   - [[file:./images/screenshot-04.png]]
   - [[file:./images/screenshot-03.png]]
** Introducing Nix Package Management
   - solves all of the problems above
     - No referential transparency
       - cannot point to older versions of the same thing
     - Dependency hell
     - Not atomic upgrades
       - unknown state if break half way
** Main mechanism
   - referential transparency
     - install everything in path ~/nix/store/{hash}-name~
     - via ~symlinking~
** What you get for free with this mechanism?
   - no ~sudo~
   - easy revert and roll back
   - select specific version
   - 2 different version can run at the same time
   - same *development* environment as the *runtime* environment!
     - nix-shell
*** no ~sudo~, where is my ~sudo~?
    - linux was developed as a ~time sharing~ system
    - many users were expected to share a single computer.
    - thus to manage conflicts, a ~super user~, ~root~ was required to
      install and manage packages
      #+BEGIN_SRC sh
        nix-env -iA nixos.figlet
      #+END_SRC
*** easy revert, rollback
    #+BEGIN_SRC sh
      figlet "I am here!"
    #+END_SRC
    #+BEGIN_SRC sh
      nix-env --rollback
    #+END_SRC
    #+BEGIN_SRC sh
      figlet "are you still here?"
    #+END_SRC
*** Select specific version
    #+BEGIN_SRC sh
      cd ~/projects/nix-config/
      git checkout ??
      nix-env -f ~/projects/nix-config/ -iA screenfetch
    #+END_SRC
    screenfetch 2016 vs current
*** Installing and running 2 version of same software
    #+BEGIN_SRC sh
      stack --version
      su
      stack --version
    #+END_SRC
*** Same development environment and runtime environment
    - I am not an electrical engineer or something but I program my
      own keyboard. So I need some sort of firmware flasher. like
      ~dfuprogrammer~ I dont need it on my system.
    #+BEGIN_SRC sh
      cd ~/projects/qmk_firmware/
      make
      dfuprogrammer
      nix-shell
      make
      dfuprogrammer
    #+END_SRC
** Going all the way, NixOS
   - whole system management via Nix and thus NixOS
     - Version controlled operating system
     - show OS reboot
     - I wanted to show my generations so had been delaying removing
       my older generations
   #+BEGIN_SRC sh
     df -h /
     nix-collect-garbage --delete-older-than 10 --dry-run
   #+END_SRC
*** NixOS
    - show [[file+emacs:~/nix-config/configuration.nix]]
    - python package management [[file+emacs:~/nix-config/configuration.nix]]
    - gnupg agent [[file+emacs:~/nix-config/configuration.nix]]
    - ports [[file+emacs:~/nix-config/configuration.nix]]
      - I think it helps me get a state of all the ports in one place
    - users and security all in one place
      [[file+emacs:~/nix-config/configuration.nix]]
      - authorisedkeys
    - postgresql can be packaged in ~shell.nix~
      [[file+emacs:~/nix-config/configuration.nix]]
      - separate project called ~nixos-shell~
        [[https://github.com/chrisfarms/nixos-shell]]
    - filesystems [[file+emacs:/etc/nixos/hardware-configuration.nix]]
*** COMMENT NixOS
    - show [[file+emacs:~/nix-config/configuration.nix]]
    - python package management [[file+emacs:~/nix-config/configuration.nix::84]]
    - gnupg agent [[file+emacs:~/nix-config/configuration.nix::289]]
    - ports [[file+emacs:~/nix-config/configuration.nix::324]]
      - I think it helps me get a state of all the ports in one place
    - users and security all in one place
      [[file+emacs:~/nix-config/configuration.nix::400]]
      - authorisedkeys
    - postgresql can be packaged in ~shell.nix~
      [[file+emacs:~/nix-config/configuration.nix::426]]
      - separate project called ~nixos-shell~
        [[https://github.com/chrisfarms/nixos-shell]]
    - filesystems [[file+emacs:/etc/nixos/hardware-configuration.nix::23]]
*** docker
    [[https://nixos.wiki/wiki/Docker]]
    #+BEGIN_SRC nix
      virtualisation.docker.enable = true;
      users.users.<myuser>.extraGroups = [ "docker" ];
    #+END_SRC
    #+BEGIN_SRC sh
      nix-build '<nixpkgs>' -A dockerTools.examples.redis
      docker load < result
    #+END_SRC
    [[https://github.com/NixOS/nixpkgs/blob/master/pkgs/build-support/docker/examples.nix]]
*** easy cd/dvd
    #+BEGIN_SRC sh
      cd ~/projects/nixpkgs
      nix-build -A config.system.build.isoImage -I nixos-config=modules/installer/cd-dvd/installation-cd-minimal.nix default.nix
    #+END_SRC
*** easy vm
    #+BEGIN_SRC sh
      cd ./nixops
      nixops create -d simple02 network.nix
      nixops deploy -d simple02
    #+END_SRC
    #+BEGIN_SRC nix
      deployment.targetEnv = "ec2";
      deployment.region = "eu-west-1";
    #+END_SRC
* How does nix actually work?
** Nix expressions
   - functional expressions, not general purpose please do not program
     things with it
   - comes with its own BNF grammar
   [[file:./images/screenshot-05.png]]
** Language features
   - Nix expressions
     - dynamically typed
     - lazy
     - pure
** The main point
   - Nix expressions are here to describe a graph of build actions
     called ~derivations~
     - build script
     - set of environment variables
     - set of dependencies
** Example: Xmonad
   [[file:./images/screenshot-06.png]]
** Example: Xmonad
   [[file:./images/screenshot-07.png]]
** Main mechanism
   [[file:./images/screenshot-08.png]]
